{"version":3,"file":"path.cjs","sources":["../../src/path.ts"],"sourcesContent":["import { last } from './utils'\nimport type { MatchLocation } from './RouterProvider'\nimport type { AnyPathParams } from './route'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n  // Add a new property to store the static segment if present\n  prefixSegment?: string\n  suffixSegment?: string\n}\n\nexport function joinPaths(paths: Array<string | undefined>) {\n  return cleanPath(\n    paths\n      .filter((val) => {\n        return val !== undefined\n      })\n      .join('/'),\n  )\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function removeTrailingSlash(value: string, basepath: string): string {\n  if (value?.endsWith('/') && value !== '/' && value !== `${basepath}/`) {\n    return value.slice(0, -1)\n  }\n  return value\n}\n\n// intended to only compare path name\n// see the usage in the isActive under useLinkProps\n// /sample/path1 = /sample/path1/\n// /sample/path1/some <> /sample/path1\nexport function exactPathTest(\n  pathName1: string,\n  pathName2: string,\n  basepath: string,\n): boolean {\n  return (\n    removeTrailingSlash(pathName1, basepath) ===\n    removeTrailingSlash(pathName2, basepath)\n  )\n}\n\n// When resolving relative paths, we treat all paths as if they are trailing slash\n// documents. All trailing slashes are removed after the path is resolved.\n// Here are a few examples:\n//\n// /a/b/c + ./d = /a/b/c/d\n// /a/b/c + ../d = /a/b/d\n// /a/b/c + ./d/ = /a/b/c/d\n// /a/b/c + ../d/ = /a/b/d\n// /a/b/c + ./ = /a/b/c\n//\n// Absolute paths that start with `/` short circuit the resolution process to the root\n// path.\n//\n// Here are some examples:\n//\n// /a/b/c + /d = /d\n// /a/b/c + /d/ = /d\n// /a/b/c + / = /\n//\n// Non-.-prefixed paths are still treated as relative paths, resolved like `./`\n//\n// Here are some examples:\n//\n// /a/b/c + d = /a/b/c/d\n// /a/b/c + d/ = /a/b/c/d\n// /a/b/c + d/e = /a/b/c/d/e\ninterface ResolvePathOptions {\n  basepath: string\n  base: string\n  to: string\n  trailingSlash?: 'always' | 'never' | 'preserve'\n  caseSensitive?: boolean\n}\n\nexport function resolvePath({\n  basepath,\n  base,\n  to,\n  trailingSlash = 'never',\n  caseSensitive,\n}: ResolvePathOptions) {\n  base = removeBasepath(basepath, base, caseSensitive)\n  to = removeBasepath(basepath, to, caseSensitive)\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      // ignore\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  if (baseSegments.length > 1) {\n    if (last(baseSegments)?.value === '/') {\n      if (trailingSlash === 'never') {\n        baseSegments.pop()\n      }\n    } else if (trailingSlash === 'always') {\n      baseSegments.push({ type: 'pathname', value: '/' })\n    }\n  }\n\n  const segmentValues = baseSegments.map((segment) => {\n    if (segment.type === 'param') {\n      const param = segment.value.substring(1)\n      if (segment.prefixSegment && segment.suffixSegment) {\n        return `${segment.prefixSegment}{$${param}}${segment.suffixSegment}`\n      } else if (segment.prefixSegment) {\n        return `${segment.prefixSegment}{$${param}}`\n      } else if (segment.suffixSegment) {\n        return `{$${param}}${segment.suffixSegment}`\n      }\n    }\n    if (segment.type === 'wildcard') {\n      if (segment.prefixSegment && segment.suffixSegment) {\n        return `${segment.prefixSegment}{$}${segment.suffixSegment}`\n      } else if (segment.prefixSegment) {\n        return `${segment.prefixSegment}{$}`\n      } else if (segment.suffixSegment) {\n        return `{$}${segment.suffixSegment}`\n      }\n    }\n    return segment.value\n  })\n  const joined = joinPaths([basepath, ...segmentValues])\n  return cleanPath(joined)\n}\n\nconst PARAM_RE = /^\\$.{1,}$/ // $paramName\nconst PARAM_W_CURLY_BRACES_RE = /^(.*?)\\{(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/ // prefix{$paramName}suffix\nconst WILDCARD_RE = /^\\$$/ // $\nconst WILDCARD_W_CURLY_BRACES_RE = /^(.*?)\\{\\$\\}(.*)$/ // prefix{$}suffix\n\n/**\n * Required: `/foo/$bar` ✅\n * Prefix and Suffix: `/foo/prefix${bar}suffix` ✅\n * Wildcard: `/foo/$` ✅\n * Wildcard with Prefix and Suffix: `/foo/prefix{$}suffix` ✅\n *\n * Future:\n * Optional: `/foo/{-bar}`\n * Optional named segment: `/foo/{bar}`\n * Optional named segment with Prefix and Suffix: `/foo/prefix{-bar}suffix`\n * Escape special characters:\n * - `/foo/[$]` - Static route\n * - `/foo/[$]{$foo} - Dynamic route with a static prefix of `$`\n * - `/foo/{$foo}[$]` - Dynamic route with a static suffix of `$`\n */\nexport function parsePathname(pathname?: string): Array<Segment> {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Array<Segment> = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      // Check for wildcard with curly braces: prefix{$}suffix\n      const wildcardBracesMatch = part.match(WILDCARD_W_CURLY_BRACES_RE)\n      if (wildcardBracesMatch) {\n        const prefix = wildcardBracesMatch[1]\n        const suffix = wildcardBracesMatch[2]\n        return {\n          type: 'wildcard',\n          value: '$',\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for the new parameter format: prefix{$paramName}suffix\n      const paramBracesMatch = part.match(PARAM_W_CURLY_BRACES_RE)\n      if (paramBracesMatch) {\n        const prefix = paramBracesMatch[1]\n        const paramName = paramBracesMatch[2]\n        const suffix = paramBracesMatch[3]\n        return {\n          type: 'param',\n          value: '' + paramName,\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for bare parameter format: $paramName (without curly braces)\n      if (PARAM_RE.test(part)) {\n        const paramName = part.substring(1)\n        return {\n          type: 'param',\n          value: '$' + paramName,\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Check for bare wildcard: $ (without curly braces)\n      if (WILDCARD_RE.test(part)) {\n        return {\n          type: 'wildcard',\n          value: '$',\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Handle regular pathname segment\n      return {\n        type: 'pathname',\n        value: part.includes('%25')\n          ? part\n              .split('%25')\n              .map((segment) => decodeURI(segment))\n              .join('%25')\n          : decodeURI(part),\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\ninterface InterpolatePathOptions {\n  path?: string\n  params: Record<string, unknown>\n  leaveWildcards?: boolean\n  leaveParams?: boolean\n  // Map of encoded chars to decoded chars (e.g. '%40' -> '@') that should remain decoded in path params\n  decodeCharMap?: Map<string, string>\n}\n\ntype InterPolatePathResult = {\n  interpolatedPath: string\n  usedParams: Record<string, unknown>\n  isMissingParams: boolean // true if any params were not available when being looked up in the params object\n}\nexport function interpolatePath({\n  path,\n  params,\n  leaveWildcards,\n  leaveParams,\n  decodeCharMap,\n}: InterpolatePathOptions): InterPolatePathResult {\n  const interpolatedPathSegments = parsePathname(path)\n\n  function encodeParam(key: string): any {\n    const value = params[key]\n    const isValueString = typeof value === 'string'\n\n    if (['*', '_splat'].includes(key)) {\n      // the splat/catch-all routes shouldn't have the '/' encoded out\n      return isValueString ? encodeURI(value) : value\n    } else {\n      return isValueString ? encodePathParam(value, decodeCharMap) : value\n    }\n  }\n\n  // Tracking if any params are missing in the `params` object\n  // when interpolating the path\n  let isMissingParams = false\n\n  const usedParams: Record<string, unknown> = {}\n  const interpolatedPath = joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        usedParams._splat = params._splat\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n        const value = encodeParam('_splat')\n        if (leaveWildcards) {\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${value}${segmentSuffix}`\n      }\n\n      if (segment.type === 'param') {\n        const key = segment.value.substring(1)\n        if (!isMissingParams && !(key in params)) {\n          isMissingParams = true\n        }\n        usedParams[key] = params[key]\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? 'undefined'}${segmentSuffix}`\n      }\n\n      return segment.value\n    }),\n  )\n  return { usedParams, interpolatedPath, isMissingParams }\n}\n\nfunction encodePathParam(value: string, decodeCharMap?: Map<string, string>) {\n  let encoded = encodeURIComponent(value)\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char)\n    }\n  }\n  return encoded\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function removeBasepath(\n  basepath: string,\n  pathname: string,\n  caseSensitive: boolean = false,\n) {\n  // normalize basepath and pathname for case-insensitive comparison if needed\n  const normalizedBasepath = caseSensitive ? basepath : basepath.toLowerCase()\n  const normalizedPathname = caseSensitive ? pathname : pathname.toLowerCase()\n\n  switch (true) {\n    // default behaviour is to serve app from the root - pathname\n    // left untouched\n    case normalizedBasepath === '/':\n      return pathname\n\n    // shortcut for removing the basepath if it matches the pathname\n    case normalizedPathname === normalizedBasepath:\n      return ''\n\n    // in case pathname is shorter than basepath - there is\n    // nothing to remove\n    case pathname.length < basepath.length:\n      return pathname\n\n    // avoid matching partial segments - strict equality handled\n    // earlier, otherwise, basepath separated from pathname with\n    // separator, therefore lack of separator means partial\n    // segment match (`/app` should not match `/application`)\n    case normalizedPathname[normalizedBasepath.length] !== '/':\n      return pathname\n\n    // remove the basepath from the pathname if it starts with it\n    case normalizedPathname.startsWith(normalizedBasepath):\n      return pathname.slice(basepath.length)\n\n    // otherwise, return the pathname as is\n    default:\n      return pathname\n  }\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // check basepath first\n  if (basepath !== '/' && !from.startsWith(basepath)) {\n    return undefined\n  }\n  // Remove the base path from the pathname\n  from = removeBasepath(basepath, from, matchLocation.caseSensitive)\n  // Default to to $ (wildcard)\n  const to = removeBasepath(\n    basepath,\n    `${matchLocation.to ?? '$'}`,\n    matchLocation.caseSensitive,\n  )\n\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  const isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          // Capture all remaining segments for a wildcard\n          const remainingBaseSegments = baseSegments.slice(i)\n\n          let _splat: string\n\n          // If this is a wildcard with prefix/suffix, we need to handle the first segment specially\n          if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n            if (!baseSegment) return false\n\n            const prefix = routeSegment.prefixSegment || ''\n            const suffix = routeSegment.suffixSegment || ''\n\n            // Check if the base segment starts with prefix and ends with suffix\n            const baseValue = baseSegment.value\n            if ('prefixSegment' in routeSegment) {\n              if (!baseValue.startsWith(prefix)) {\n                return false\n              }\n            }\n            if ('suffixSegment' in routeSegment) {\n              if (\n                !baseSegments[baseSegments.length - 1]?.value.endsWith(suffix)\n              ) {\n                return false\n              }\n            }\n\n            let rejoinedSplat = decodeURI(\n              joinPaths(remainingBaseSegments.map((d) => d.value)),\n            )\n\n            // Remove the prefix and suffix from the rejoined splat\n            if (prefix && rejoinedSplat.startsWith(prefix)) {\n              rejoinedSplat = rejoinedSplat.slice(prefix.length)\n            }\n\n            if (suffix && rejoinedSplat.endsWith(suffix)) {\n              rejoinedSplat = rejoinedSplat.slice(\n                0,\n                rejoinedSplat.length - suffix.length,\n              )\n            }\n\n            _splat = rejoinedSplat\n          } else {\n            // If no prefix/suffix, just rejoin the remaining segments\n            _splat = decodeURI(\n              joinPaths(remainingBaseSegments.map((d) => d.value)),\n            )\n          }\n\n          // TODO: Deprecate *\n          params['*'] = _splat\n          params['_splat'] = _splat\n          return true\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment.value === '/') {\n            return false\n          }\n\n          let _paramValue: string\n\n          // If this param has prefix/suffix, we need to extract the actual parameter value\n          if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n            const prefix = routeSegment.prefixSegment || ''\n            const suffix = routeSegment.suffixSegment || ''\n\n            // Check if the base segment starts with prefix and ends with suffix\n            const baseValue = baseSegment.value\n            if (prefix && !baseValue.startsWith(prefix)) {\n              return false\n            }\n            if (suffix && !baseValue.endsWith(suffix)) {\n              return false\n            }\n\n            let paramValue = baseValue\n            if (prefix && paramValue.startsWith(prefix)) {\n              paramValue = paramValue.slice(prefix.length)\n            }\n            if (suffix && paramValue.endsWith(suffix)) {\n              paramValue = paramValue.slice(\n                0,\n                paramValue.length - suffix.length,\n              )\n            }\n\n            _paramValue = decodeURIComponent(paramValue)\n          } else {\n            // If no prefix/suffix, just decode the base segment value\n            _paramValue = decodeURIComponent(baseSegment.value)\n          }\n\n          params[routeSegment.value.substring(1)] = _paramValue\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        params['**'] = joinPaths(baseSegments.slice(i + 1).map((d) => d.value))\n        return !!matchLocation.fuzzy && routeSegment?.value !== '/'\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? params : undefined\n}\n"],"names":["last"],"mappings":";;;AAYO,SAAS,UAAU,OAAkC;AACnD,SAAA;AAAA,IACL,MACG,OAAO,CAAC,QAAQ;AACf,aAAO,QAAQ;AAAA,IAAA,CAChB,EACA,KAAK,GAAG;AAAA,EACb;AACF;AAEO,SAAS,UAAU,MAAc;AAE/B,SAAA,KAAK,QAAQ,WAAW,GAAG;AACpC;AAEO,SAAS,aAAa,MAAc;AACzC,SAAO,SAAS,MAAM,OAAO,KAAK,QAAQ,WAAW,EAAE;AACzD;AAEO,SAAS,cAAc,MAAc;AAC1C,SAAO,SAAS,MAAM,OAAO,KAAK,QAAQ,WAAW,EAAE;AACzD;AAEO,SAAS,SAAS,MAAc;AAC9B,SAAA,cAAc,aAAa,IAAI,CAAC;AACzC;AAEgB,SAAA,oBAAoB,OAAe,UAA0B;AACvE,OAAA,+BAAO,SAAS,SAAQ,UAAU,OAAO,UAAU,GAAG,QAAQ,KAAK;AAC9D,WAAA,MAAM,MAAM,GAAG,EAAE;AAAA,EAAA;AAEnB,SAAA;AACT;AAMgB,SAAA,cACd,WACA,WACA,UACS;AACT,SACE,oBAAoB,WAAW,QAAQ,MACvC,oBAAoB,WAAW,QAAQ;AAE3C;AAoCO,SAAS,YAAY;AAAA,EAC1B;AAAA,EACA;AAAA,EACA;AAAA,EACA,gBAAgB;AAAA,EAChB;AACF,GAAuB;;AACd,SAAA,eAAe,UAAU,MAAM,aAAa;AAC9C,OAAA,eAAe,UAAU,IAAI,aAAa;AAE3C,MAAA,eAAe,cAAc,IAAI;AAC/B,QAAA,aAAa,cAAc,EAAE;AAEnC,MAAI,aAAa,SAAS,OAAKA,gBAAK,YAAY,MAAjBA,mBAAoB,WAAU,KAAK;AAChE,iBAAa,IAAI;AAAA,EAAA;AAGR,aAAA,QAAQ,CAAC,WAAW,UAAU;AACnC,QAAA,UAAU,UAAU,KAAK;AAC3B,UAAI,CAAC,OAAO;AAEV,uBAAe,CAAC,SAAS;AAAA,MAChB,WAAA,UAAU,WAAW,SAAS,GAAG;AAE1C,qBAAa,KAAK,SAAS;AAAA,MAAA,MACtB;AAAA,IAEP,WACS,UAAU,UAAU,MAAM;AACnC,mBAAa,IAAI;AAAA,IACnB,WAAW,UAAU,UAAU,IAAK;AAAA,SAE7B;AACL,mBAAa,KAAK,SAAS;AAAA,IAAA;AAAA,EAC7B,CACD;AAEG,MAAA,aAAa,SAAS,GAAG;AAC3B,UAAIA,gBAAK,YAAY,MAAjBA,mBAAoB,WAAU,KAAK;AACrC,UAAI,kBAAkB,SAAS;AAC7B,qBAAa,IAAI;AAAA,MAAA;AAAA,IACnB,WACS,kBAAkB,UAAU;AACrC,mBAAa,KAAK,EAAE,MAAM,YAAY,OAAO,KAAK;AAAA,IAAA;AAAA,EACpD;AAGF,QAAM,gBAAgB,aAAa,IAAI,CAAC,YAAY;AAC9C,QAAA,QAAQ,SAAS,SAAS;AAC5B,YAAM,QAAQ,QAAQ,MAAM,UAAU,CAAC;AACnC,UAAA,QAAQ,iBAAiB,QAAQ,eAAe;AAClD,eAAO,GAAG,QAAQ,aAAa,KAAK,KAAK,IAAI,QAAQ,aAAa;AAAA,MAAA,WACzD,QAAQ,eAAe;AAChC,eAAO,GAAG,QAAQ,aAAa,KAAK,KAAK;AAAA,MAAA,WAChC,QAAQ,eAAe;AAChC,eAAO,KAAK,KAAK,IAAI,QAAQ,aAAa;AAAA,MAAA;AAAA,IAC5C;AAEE,QAAA,QAAQ,SAAS,YAAY;AAC3B,UAAA,QAAQ,iBAAiB,QAAQ,eAAe;AAClD,eAAO,GAAG,QAAQ,aAAa,MAAM,QAAQ,aAAa;AAAA,MAAA,WACjD,QAAQ,eAAe;AACzB,eAAA,GAAG,QAAQ,aAAa;AAAA,MAAA,WACtB,QAAQ,eAAe;AACzB,eAAA,MAAM,QAAQ,aAAa;AAAA,MAAA;AAAA,IACpC;AAEF,WAAO,QAAQ;AAAA,EAAA,CAChB;AACD,QAAM,SAAS,UAAU,CAAC,UAAU,GAAG,aAAa,CAAC;AACrD,SAAO,UAAU,MAAM;AACzB;AAEA,MAAM,WAAW;AACjB,MAAM,0BAA0B;AAChC,MAAM,cAAc;AACpB,MAAM,6BAA6B;AAiB5B,SAAS,cAAc,UAAmC;AAC/D,MAAI,CAAC,UAAU;AACb,WAAO,CAAC;AAAA,EAAA;AAGV,aAAW,UAAU,QAAQ;AAE7B,QAAM,WAA2B,CAAC;AAElC,MAAI,SAAS,MAAM,GAAG,CAAC,MAAM,KAAK;AACrB,eAAA,SAAS,UAAU,CAAC;AAC/B,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,OAAO;AAAA,IAAA,CACR;AAAA,EAAA;AAGH,MAAI,CAAC,UAAU;AACN,WAAA;AAAA,EAAA;AAIT,QAAM,QAAQ,SAAS,MAAM,GAAG,EAAE,OAAO,OAAO;AAEvC,WAAA;AAAA,IACP,GAAG,MAAM,IAAI,CAAC,SAAkB;AAExB,YAAA,sBAAsB,KAAK,MAAM,0BAA0B;AACjE,UAAI,qBAAqB;AACjB,cAAA,SAAS,oBAAoB,CAAC;AAC9B,cAAA,SAAS,oBAAoB,CAAC;AAC7B,eAAA;AAAA,UACL,MAAM;AAAA,UACN,OAAO;AAAA,UACP,eAAe,UAAU;AAAA,UACzB,eAAe,UAAU;AAAA,QAC3B;AAAA,MAAA;AAII,YAAA,mBAAmB,KAAK,MAAM,uBAAuB;AAC3D,UAAI,kBAAkB;AACd,cAAA,SAAS,iBAAiB,CAAC;AAC3B,cAAA,YAAY,iBAAiB,CAAC;AAC9B,cAAA,SAAS,iBAAiB,CAAC;AAC1B,eAAA;AAAA,UACL,MAAM;AAAA,UACN,OAAO,KAAK;AAAA,UACZ,eAAe,UAAU;AAAA,UACzB,eAAe,UAAU;AAAA,QAC3B;AAAA,MAAA;AAIE,UAAA,SAAS,KAAK,IAAI,GAAG;AACjB,cAAA,YAAY,KAAK,UAAU,CAAC;AAC3B,eAAA;AAAA,UACL,MAAM;AAAA,UACN,OAAO,MAAM;AAAA,UACb,eAAe;AAAA,UACf,eAAe;AAAA,QACjB;AAAA,MAAA;AAIE,UAAA,YAAY,KAAK,IAAI,GAAG;AACnB,eAAA;AAAA,UACL,MAAM;AAAA,UACN,OAAO;AAAA,UACP,eAAe;AAAA,UACf,eAAe;AAAA,QACjB;AAAA,MAAA;AAIK,aAAA;AAAA,QACL,MAAM;AAAA,QACN,OAAO,KAAK,SAAS,KAAK,IACtB,KACG,MAAM,KAAK,EACX,IAAI,CAAC,YAAY,UAAU,OAAO,CAAC,EACnC,KAAK,KAAK,IACb,UAAU,IAAI;AAAA,MACpB;AAAA,IACD,CAAA;AAAA,EACH;AAEA,MAAI,SAAS,MAAM,EAAE,MAAM,KAAK;AACnB,eAAA,SAAS,UAAU,CAAC;AAC/B,aAAS,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,OAAO;AAAA,IAAA,CACR;AAAA,EAAA;AAGI,SAAA;AACT;AAgBO,SAAS,gBAAgB;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAkD;AAC1C,QAAA,2BAA2B,cAAc,IAAI;AAEnD,WAAS,YAAY,KAAkB;AAC/B,UAAA,QAAQ,OAAO,GAAG;AAClB,UAAA,gBAAgB,OAAO,UAAU;AAEvC,QAAI,CAAC,KAAK,QAAQ,EAAE,SAAS,GAAG,GAAG;AAE1B,aAAA,gBAAgB,UAAU,KAAK,IAAI;AAAA,IAAA,OACrC;AACL,aAAO,gBAAgB,gBAAgB,OAAO,aAAa,IAAI;AAAA,IAAA;AAAA,EACjE;AAKF,MAAI,kBAAkB;AAEtB,QAAM,aAAsC,CAAC;AAC7C,QAAM,mBAAmB;AAAA,IACvB,yBAAyB,IAAI,CAAC,YAAY;AACpC,UAAA,QAAQ,SAAS,YAAY;AAC/B,mBAAW,SAAS,OAAO;AACrB,cAAA,gBAAgB,QAAQ,iBAAiB;AACzC,cAAA,gBAAgB,QAAQ,iBAAiB;AACzC,cAAA,QAAQ,YAAY,QAAQ;AAClC,YAAI,gBAAgB;AACX,iBAAA,GAAG,aAAa,GAAG,QAAQ,KAAK,GAAG,SAAS,EAAE,GAAG,aAAa;AAAA,QAAA;AAEvE,eAAO,GAAG,aAAa,GAAG,KAAK,GAAG,aAAa;AAAA,MAAA;AAG7C,UAAA,QAAQ,SAAS,SAAS;AAC5B,cAAM,MAAM,QAAQ,MAAM,UAAU,CAAC;AACrC,YAAI,CAAC,mBAAmB,EAAE,OAAO,SAAS;AACtB,4BAAA;AAAA,QAAA;AAET,mBAAA,GAAG,IAAI,OAAO,GAAG;AAEtB,cAAA,gBAAgB,QAAQ,iBAAiB;AACzC,cAAA,gBAAgB,QAAQ,iBAAiB;AAC/C,YAAI,aAAa;AACT,gBAAA,QAAQ,YAAY,QAAQ,KAAK;AAChC,iBAAA,GAAG,aAAa,GAAG,QAAQ,KAAK,GAAG,SAAS,EAAE,GAAG,aAAa;AAAA,QAAA;AAEhE,eAAA,GAAG,aAAa,GAAG,YAAY,GAAG,KAAK,WAAW,GAAG,aAAa;AAAA,MAAA;AAG3E,aAAO,QAAQ;AAAA,IAChB,CAAA;AAAA,EACH;AACO,SAAA,EAAE,YAAY,kBAAkB,gBAAgB;AACzD;AAEA,SAAS,gBAAgB,OAAe,eAAqC;AACvE,MAAA,UAAU,mBAAmB,KAAK;AACtC,MAAI,eAAe;AACjB,eAAW,CAAC,aAAa,IAAI,KAAK,eAAe;AACrC,gBAAA,QAAQ,WAAW,aAAa,IAAI;AAAA,IAAA;AAAA,EAChD;AAEK,SAAA;AACT;AAEgB,SAAA,cACd,UACA,iBACA,eAC2B;AAC3B,QAAM,aAAa,YAAY,UAAU,iBAAiB,aAAa;AAGnE,MAAA,cAAc,MAAM,CAAC,YAAY;AACnC;AAAA,EAAA;AAGF,SAAO,cAAc,CAAC;AACxB;AAEO,SAAS,eACd,UACA,UACA,gBAAyB,OACzB;AAEA,QAAM,qBAAqB,gBAAgB,WAAW,SAAS,YAAY;AAC3E,QAAM,qBAAqB,gBAAgB,WAAW,SAAS,YAAY;AAE3E,UAAQ,MAAM;AAAA;AAAA;AAAA,IAGZ,KAAK,uBAAuB;AACnB,aAAA;AAAA;AAAA,IAGT,KAAK,uBAAuB;AACnB,aAAA;AAAA;AAAA;AAAA,IAIT,KAAK,SAAS,SAAS,SAAS;AACvB,aAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMT,KAAK,mBAAmB,mBAAmB,MAAM,MAAM;AAC9C,aAAA;AAAA;AAAA,IAGT,KAAK,mBAAmB,WAAW,kBAAkB;AAC5C,aAAA,SAAS,MAAM,SAAS,MAAM;AAAA;AAAA,IAGvC;AACS,aAAA;AAAA,EAAA;AAEb;AAEgB,SAAA,YACd,UACA,MACA,eACoC;AAEpC,MAAI,aAAa,OAAO,CAAC,KAAK,WAAW,QAAQ,GAAG;AAC3C,WAAA;AAAA,EAAA;AAGT,SAAO,eAAe,UAAU,MAAM,cAAc,aAAa;AAEjE,QAAM,KAAK;AAAA,IACT;AAAA,IACA,GAAG,cAAc,MAAM,GAAG;AAAA,IAC1B,cAAc;AAAA,EAChB;AAGM,QAAA,eAAe,cAAc,IAAI;AACjC,QAAA,gBAAgB,cAAc,EAAE;AAEtC,MAAI,CAAC,KAAK,WAAW,GAAG,GAAG;AACzB,iBAAa,QAAQ;AAAA,MACnB,MAAM;AAAA,MACN,OAAO;AAAA,IAAA,CACR;AAAA,EAAA;AAGH,MAAI,CAAC,GAAG,WAAW,GAAG,GAAG;AACvB,kBAAc,QAAQ;AAAA,MACpB,MAAM;AAAA,MACN,OAAO;AAAA,IAAA,CACR;AAAA,EAAA;AAGH,QAAM,SAAiC,CAAC;AAExC,QAAM,WAAW,MAAM;;AAEf,aAAA,IAAI,GACR,IAAI,KAAK,IAAI,aAAa,QAAQ,cAAc,MAAM,GACtD,KACA;AACM,YAAA,cAAc,aAAa,CAAC;AAC5B,YAAA,eAAe,cAAc,CAAC;AAE9B,YAAA,oBAAoB,KAAK,aAAa,SAAS;AAC/C,YAAA,qBAAqB,KAAK,cAAc,SAAS;AAEvD,UAAI,cAAc;AACZ,YAAA,aAAa,SAAS,YAAY;AAE9B,gBAAA,wBAAwB,aAAa,MAAM,CAAC;AAE9C,cAAA;AAGA,cAAA,aAAa,iBAAiB,aAAa,eAAe;AACxD,gBAAA,CAAC,YAAoB,QAAA;AAEnB,kBAAA,SAAS,aAAa,iBAAiB;AACvC,kBAAA,SAAS,aAAa,iBAAiB;AAG7C,kBAAM,YAAY,YAAY;AAC9B,gBAAI,mBAAmB,cAAc;AACnC,kBAAI,CAAC,UAAU,WAAW,MAAM,GAAG;AAC1B,uBAAA;AAAA,cAAA;AAAA,YACT;AAEF,gBAAI,mBAAmB,cAAc;AAEjC,kBAAA,GAAC,kBAAa,aAAa,SAAS,CAAC,MAApC,mBAAuC,MAAM,SAAS,UACvD;AACO,uBAAA;AAAA,cAAA;AAAA,YACT;AAGF,gBAAI,gBAAgB;AAAA,cAClB,UAAU,sBAAsB,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC;AAAA,YACrD;AAGA,gBAAI,UAAU,cAAc,WAAW,MAAM,GAAG;AAC9B,8BAAA,cAAc,MAAM,OAAO,MAAM;AAAA,YAAA;AAGnD,gBAAI,UAAU,cAAc,SAAS,MAAM,GAAG;AAC5C,8BAAgB,cAAc;AAAA,gBAC5B;AAAA,gBACA,cAAc,SAAS,OAAO;AAAA,cAChC;AAAA,YAAA;AAGO,qBAAA;AAAA,UAAA,OACJ;AAEI,qBAAA;AAAA,cACP,UAAU,sBAAsB,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC;AAAA,YACrD;AAAA,UAAA;AAIF,iBAAO,GAAG,IAAI;AACd,iBAAO,QAAQ,IAAI;AACZ,iBAAA;AAAA,QAAA;AAGL,YAAA,aAAa,SAAS,YAAY;AACpC,cAAI,aAAa,UAAU,OAAO,EAAC,2CAAa,QAAO;AAC9C,mBAAA;AAAA,UAAA;AAGT,cAAI,aAAa;AACf,gBAAI,cAAc,eAAe;AAC3B,kBAAA,aAAa,UAAU,YAAY,OAAO;AACrC,uBAAA;AAAA,cAAA;AAAA,YACT,WAEA,aAAa,MAAM,kBACnB,YAAY,MAAM,eAClB;AACO,qBAAA;AAAA,YAAA;AAAA,UACT;AAAA,QACF;AAGF,YAAI,CAAC,aAAa;AACT,iBAAA;AAAA,QAAA;AAGL,YAAA,aAAa,SAAS,SAAS;AAC7B,cAAA,YAAY,UAAU,KAAK;AACtB,mBAAA;AAAA,UAAA;AAGL,cAAA;AAGA,cAAA,aAAa,iBAAiB,aAAa,eAAe;AACtD,kBAAA,SAAS,aAAa,iBAAiB;AACvC,kBAAA,SAAS,aAAa,iBAAiB;AAG7C,kBAAM,YAAY,YAAY;AAC9B,gBAAI,UAAU,CAAC,UAAU,WAAW,MAAM,GAAG;AACpC,qBAAA;AAAA,YAAA;AAET,gBAAI,UAAU,CAAC,UAAU,SAAS,MAAM,GAAG;AAClC,qBAAA;AAAA,YAAA;AAGT,gBAAI,aAAa;AACjB,gBAAI,UAAU,WAAW,WAAW,MAAM,GAAG;AAC9B,2BAAA,WAAW,MAAM,OAAO,MAAM;AAAA,YAAA;AAE7C,gBAAI,UAAU,WAAW,SAAS,MAAM,GAAG;AACzC,2BAAa,WAAW;AAAA,gBACtB;AAAA,gBACA,WAAW,SAAS,OAAO;AAAA,cAC7B;AAAA,YAAA;AAGF,0BAAc,mBAAmB,UAAU;AAAA,UAAA,OACtC;AAES,0BAAA,mBAAmB,YAAY,KAAK;AAAA,UAAA;AAGpD,iBAAO,aAAa,MAAM,UAAU,CAAC,CAAC,IAAI;AAAA,QAAA;AAAA,MAC5C;AAGE,UAAA,CAAC,qBAAqB,oBAAoB;AAC5C,eAAO,IAAI,IAAI,UAAU,aAAa,MAAM,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC;AACtE,eAAO,CAAC,CAAC,cAAc,UAAS,6CAAc,WAAU;AAAA,MAAA;AAAA,IAC1D;AAGK,WAAA;AAAA,EAAA,GACN;AAEH,SAAO,UAAU,SAAS;AAC5B;;;;;;;;;;;;;;"}